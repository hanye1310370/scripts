DRDS 读写分离
更新时间：2017-08-04 13:53:50   分享：   
基本原理

在主实例的读请求较多、读压力比较大的时候，可以通过 DRDS 读写分离功能对读流量进行分流，减轻 RDS 主实例的读压力。

DRDS 的读写分离功能是对应用透明的设计。应用在不修改任何代码的情况下，只需要在 DRDS 控制台中调整读权重，即可将读流量按配置的比例在主 RDS 实例与多个 RDS 只读实例之间进行分流；写流量则全部到主实例，不做分流。

设置读写分离后，从主 RDS 实例读取的是强读，既实时强一致读，而只读实例上的数据是从主实例上异步复制的，存在毫秒级的延迟，因此从只读 RDS 实例读取的是弱读，属于非强一致性读。个别需要实时性、强一致性读的 SQL 可以通过 DRDS Hint 指定到主实例上执行。详细信息请参考读写分离 HINT。

非拆分模式下的读写分离

非拆分模式下，也可以用 DRDS 做读写分离，不做水平拆分。在 DRDS 控制台上创建 DRDS 数据库时，在选定一个 RDS 实例的情况下，可以选择将该 RDS 实例下的一个数据库直接引入 DRDS 做读写分离。此时不需要做数据迁移，但同时该 DRDS 数据库中的表也不能做水平拆分。

读写分离对事务的支持

读写分离仅对显式事务（即需要显式提交/回滚的事务）以外的读请求（即查询请求）有效，写请求和显式事务中的读请求（包括只读事务）均在主实例中执行，不会被分流到只读实例。

属于读请求的常见 SQL 语句：SELECT、SHOW、EXPLAIN、DESCRIBE
属于写请求的常见 SQL 语句：INSERT、REPLACE、UPDATE、DELETE、CALL
读写分离的具体操作请参考设置读写分离文档。



读写分离
更新时间：2017-08-17 14:15:52   分享：   
DRDS 提供了一种针对应用层透明的读写分离实现。但是由于 RDS 主实例与只读实例之间数据的同步存在着毫秒级别的延迟，如果在主库中变更以后需要马上读取变更的数据，则需要保证将读取数据的 SQL 下发到主实例中。针对这种需求，DRDS 提供了读写分离自定义 HINT，指定将 SQL 下发到主实例或者只读实例。

语法

/!TDDL:MASTER|SLAVE*/
在该自定义 HINT 中可以指定 SQL 是在主实例上执行还是在只读实例上执行。对于/!TDDL:SLAVE*/这个自定义 HINT，如果一个主 RDS 实例存在多个只读实例，那么 DRDS 会根据所分配的权重随机选择一个只读实例执行 SQL 语句。

注意：

DRDS 自定义 HINT 支持 /!TDDL:hint command*/ 和 /*TDDL:hint command*/ 两种格式。

如果使用 /*TDDL:hint command*/ 格式，在使用 MySQL 官方命令行客户端执行带有 DRDS 自定义 HINT 的 SQL 时，请在登录命令中加上 -c 参数。否则，由于 DRDS 自定义 HINT 是以 MySQL 注释 形式使用的，该客户端会将注释语句删除后再发送到服务端执行，导致 DRDS 自定义 HINT 失效。具体请查看 MySQL 官方客户端命令。

示例

指定 SQL 在主实例上执行：

/!TDDL:MASTER*/SELECT * FROM table_name;
在SQL语句前添加 /!TDDL:MASTER*/ 这个自定义 HINT 后，这条 SQL 将被下发到主实例上执行。

指定 SQL 在只读实例上执行：

/!TDDL:SLAVE*/SELECT * FROM table_name;
在 SQL 语句前添加 /!TDDL:SLAVE*/ 这个自定义 HINT 后，这条 SQL 将会根据所分配的权重被随机下发到某个只读实例上执行。

注意：

此读写分离自定义 HINT 仅仅针对非事务中的读 SQL 语句生效，如果 SQL 语句是写 SQL 或者 SQL 语句在事务中，那么还是会下发到 RDS 的主实例执行。
DRDS 针对 /!TDDL:SLAVE*/ 自定义 HINT，会从只读实例中按照权重随机选取一个下发 SQL 语句执行。若只读实例不存在时，不会报错，而是选取主实例执行。